---
title: 排序算法学习
date:  2016-04-09 20:00
categories:
    - NOIP教程
tags:
    - 算法
    - NOIP
    - 教案
---


我们要学习的排序算法有: **冒泡排序**,**归并排序**,**快速排序**,**使用C++的sort**.

## 冒泡排序

冒泡排序是很简单的算法,这里我们看一下它的原是就可以了

![冒泡排序](/images/冒泡排序.png)

通过的上面的图片我们可以等到下面的信息:

 1. 每一趟排序都是把最值排序在后面
 2. 对于有**n**个数的数组来说,要排序**n-1**趟
  - n个数字只**n-1**个数字就可以了,最后一个数字自动就在第一位
 3. 对第1趟排序的范围是`a[1]-->a[n-1]`
 4. 对第2趟排序的范围是`a[1]-->a[n-2]`
 5. 对第i趟排序的范围是`a[1]-->a[n-i]`


**一句话算法：第一趟循环len-1次,第二趟循环len-2次,第i趟循环len-i次**

### bubble_sort代码核心代码

```
void bubble_sort(int a[],int len){
    int i=len,j;
    for(i=1;i<=len-1;i++)
        for(j=1;j<=len-i;j++){
            if(a[j] > a[j+1]){
                tmp =a[j];
                a[j] =a[j+1]
                a[j+1]=tmp;
            }
        }
}
```


## 归并排序

原理如下:

![归并排序1](images/归并排序.png)

我们发现**归并排序**原理就是:对原来**已经有序**的两个数组就合并操作(取两个头部比较)后还是有序.

那我们的代码如下:

```
#include <cstdio>

int a[] = {2,4,6};
int b[] = {1,5};
int tmp[100];

int merge(){
	int i=0,j=0;//i,j分别指向a,b的头部
	int k=0;//k是tmp数的下标
	int len_a = sizeof(a)/sizeof(a[0]); //a的长度
	int len_b = sizeof(b)/sizeof(b[0]);//b的长度

	while(i< len_a && j< len_b){
	    if(a[i] < b[j]){
	        tmp[k++]=a[i];
	        tmp[k++]=b[j];
	    }else {
	        tmp[k++]=b[j];
	        tmp[k++]=a[i];
	    }
	    i++;j++;
	}
	while(i<len_a) {tmp[k++] = a[i];i++;}; //复制a数组的剩余
	while(j<len_b) {tmp[k++] = b[j];j++;}; //复制b数组的剩余
}

int main(){
	
	merge();
	
	int i;
	int len_a = sizeof(a)/sizeof(a[0]); //a的长度
	int len_b = sizeof(b)/sizeof(b[0]);//b的长度
	for(i=0;i<len_a+len_b;i++)
		printf("%d ",tmp[i]);
	return 0;
}
```


这里有两个问题:

 - 如果我们的数组只有一个,如何使用归并排序
 - 是不是一定要使用**tmp**数组
